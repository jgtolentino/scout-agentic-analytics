'use client';

import html2canvas from 'html2canvas';
import { jsPDF } from 'jspdf';
import Papa from 'papaparse';
import { saveAs } from 'file-saver';

export interface ExportOptions {
  filename?: string;
  format: 'png' | 'csv' | 'pdf' | 'json';
  quality?: number; // For PNG exports (0.1 to 1.0)
  orientation?: 'portrait' | 'landscape'; // For PDF exports
  includeMetadata?: boolean;
}

// PNG Export - Screenshots of charts and components
export async function exportToPNG(
  element: HTMLElement | string, 
  options: Partial<ExportOptions> = {}
): Promise<void> {
  try {
    const targetElement = typeof element === 'string' 
      ? document.querySelector(element) as HTMLElement
      : element;

    if (!targetElement) {
      throw new Error('Element not found for PNG export');
    }

    const canvas = await html2canvas(targetElement, {
      scale: 2, // High resolution
      useCORS: true,
      allowTaint: false,
      backgroundColor: '#ffffff',
      ignoreElements: (element) => {
        // Ignore elements with data-export-ignore attribute
        return element.hasAttribute('data-export-ignore');
      }
    });

    // Convert to blob
    canvas.toBlob((blob) => {
      if (blob) {
        const filename = options.filename || `export_${Date.now()}.png`;
        saveAs(blob, filename);
      }
    }, 'image/png', options.quality || 1.0);

  } catch (error) {
    console.error('PNG export failed:', error);
    throw new Error('Failed to export PNG. Please try again.');
  }
}

// CSV Export - For data tables and analytics
export async function exportToCSV(
  data: any[], 
  options: Partial<ExportOptions> = {}
): Promise<void> {
  try {
    if (!Array.isArray(data) || data.length === 0) {
      throw new Error('No data available for CSV export');
    }

    // Add metadata if requested
    let csvData = data;
    if (options.includeMetadata) {
      csvData = [
        {
          'Export Date': new Date().toISOString(),
          'Total Records': data.length,
          'Generated By': 'Scout v7.1 Dashboard',
        },
        {}, // Empty row separator
        ...data
      ];
    }

    const csv = Papa.unparse(csvData, {
      header: true,
      skipEmptyLines: true,
    });

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const filename = options.filename || `export_${Date.now()}.csv`;
    saveAs(blob, filename);

  } catch (error) {
    console.error('CSV export failed:', error);
    throw new Error('Failed to export CSV. Please try again.');
  }
}

// PDF Export - Comprehensive reports with charts
export async function exportToPDF(
  elements: (HTMLElement | string)[], 
  options: Partial<ExportOptions> = {}
): Promise<void> {
  try {
    const pdf = new jsPDF({
      orientation: options.orientation || 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);

    // Add header
    pdf.setFontSize(16);
    pdf.text('Scout v7.1 Analytics Report', margin, margin);
    
    pdf.setFontSize(10);
    pdf.text(`Generated: ${new Date().toLocaleDateString()}`, margin, margin + 10);
    
    let currentY = margin + 25;

    for (let i = 0; i < elements.length; i++) {
      const element = typeof elements[i] === 'string' 
        ? document.querySelector(elements[i] as string) as HTMLElement
        : elements[i] as HTMLElement;

      if (!element) continue;

      // Check if we need a new page
      if (currentY > pageHeight - 60) {
        pdf.addPage();
        currentY = margin;
      }

      try {
        const canvas = await html2canvas(element, {
          scale: 1,
          useCORS: true,
          allowTaint: false,
          backgroundColor: '#ffffff'
        });

        const imgData = canvas.toDataURL('image/png');
        
        // Calculate dimensions to fit page
        const imgWidth = contentWidth;
        const imgHeight = (canvas.height * imgWidth) / canvas.width;
        
        // Add image to PDF
        pdf.addImage(imgData, 'PNG', margin, currentY, imgWidth, imgHeight);
        currentY += imgHeight + 10;

      } catch (canvasError) {
        console.warn(`Failed to capture element ${i}:`, canvasError);
        // Continue with next element
      }
    }

    // Add footer
    const pageCount = pdf.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.text(
        `Page ${i} of ${pageCount} | Scout v7.1 Dashboard`, 
        margin, 
        pageHeight - 10
      );
    }

    // Save PDF
    const filename = options.filename || `report_${Date.now()}.pdf`;
    pdf.save(filename);

  } catch (error) {
    console.error('PDF export failed:', error);
    throw new Error('Failed to export PDF. Please try again.');
  }
}

// JSON Export - Raw data export
export async function exportToJSON(
  data: any, 
  options: Partial<ExportOptions> = {}
): Promise<void> {
  try {
    const exportData = options.includeMetadata ? {
      metadata: {
        exportDate: new Date().toISOString(),
        version: 'Scout v7.1',
        format: 'JSON'
      },
      data: data
    } : data;

    const jsonString = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8;' });
    const filename = options.filename || `export_${Date.now()}.json`;
    saveAs(blob, filename);

  } catch (error) {
    console.error('JSON export failed:', error);
    throw new Error('Failed to export JSON. Please try again.');
  }
}

// Universal export function
export async function exportData(
  content: HTMLElement | string | any[], 
  format: ExportOptions['format'],
  options: Partial<ExportOptions> = {}
): Promise<void> {
  const exportOptions: ExportOptions = {
    format,
    quality: 1.0,
    orientation: 'portrait',
    includeMetadata: true,
    ...options
  };

  switch (format) {
    case 'png':
      if (typeof content === 'string' || content instanceof HTMLElement) {
        await exportToPNG(content, exportOptions);
      } else {
        throw new Error('PNG export requires an HTML element');
      }
      break;
    
    case 'csv':
      if (Array.isArray(content)) {
        await exportToCSV(content, exportOptions);
      } else {
        throw new Error('CSV export requires an array of data');
      }
      break;
    
    case 'pdf':
      if (typeof content === 'string' || content instanceof HTMLElement) {
        await exportToPDF([content], exportOptions);
      } else if (Array.isArray(content)) {
        await exportToPDF(content, exportOptions);
      } else {
        throw new Error('PDF export requires HTML element(s)');
      }
      break;
    
    case 'json':
      await exportToJSON(content, exportOptions);
      break;
    
    default:
      throw new Error(`Unsupported export format: ${format}`);
  }
}

// Chart-specific export helpers
export async function exportChart(
  chartElement: HTMLElement | string,
  format: 'png' | 'pdf',
  title?: string
): Promise<void> {
  const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
  const filename = `${title || 'chart'}_${timestamp}`;
  
  await exportData(chartElement, format, {
    filename: `${filename}.${format}`,
    quality: 1.0
  });
}

// Dashboard export - Multiple charts and data
export async function exportDashboard(
  elements: (HTMLElement | string)[],
  data: any[] = [],
  title: string = 'Dashboard'
): Promise<void> {
  const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
  const baseFilename = `${title.toLowerCase().replace(/\s+/g, '_')}_${timestamp}`;

  try {
    // Export PDF with all visual elements
    await exportToPDF(elements, {
      filename: `${baseFilename}_report.pdf`,
      orientation: 'landscape',
      includeMetadata: true
    });

    // Export CSV if data is available
    if (data.length > 0) {
      await exportToCSV(data, {
        filename: `${baseFilename}_data.csv`,
        includeMetadata: true
      });
    }

    console.log('Dashboard exported successfully');
  } catch (error) {
    console.error('Dashboard export failed:', error);
    throw error;
  }
}

// Batch export utility
export async function batchExport(
  exports: Array<{
    content: HTMLElement | string | any[];
    format: ExportOptions['format'];
    filename?: string;
  }>
): Promise<void> {
  const promises = exports.map(({ content, format, filename }) =>
    exportData(content, format, { filename })
  );

  try {
    await Promise.all(promises);
    console.log('Batch export completed successfully');
  } catch (error) {
    console.error('Batch export failed:', error);
    throw error;
  }
}

// Helper to prepare chart data for CSV export
export function prepareChartDataForCSV(plotlyData: any[]): any[] {
  const csvData: any[] = [];

  plotlyData.forEach((trace, traceIndex) => {
    if (trace.x && trace.y) {
      // Handle standard x,y data
      const length = Math.max(trace.x.length, trace.y.length);
      for (let i = 0; i < length; i++) {
        csvData.push({
          trace: trace.name || `Trace ${traceIndex + 1}`,
          x: trace.x[i] || '',
          y: trace.y[i] || '',
          text: trace.text?.[i] || '',
        });
      }
    } else if (trace.values && trace.labels) {
      // Handle pie chart data
      for (let i = 0; i < trace.values.length; i++) {
        csvData.push({
          trace: trace.name || `Trace ${traceIndex + 1}`,
          label: trace.labels[i],
          value: trace.values[i],
        });
      }
    }
  });

  return csvData;
}