#!/usr/bin/env tsx

import { createClient } from '@supabase/supabase-js';
import { config } from 'dotenv';
import fs from 'fs';
import path from 'path';
import { scoutFilterConfigs } from '../apps/web/src/components/HierarchicalFilter/types';

// Load environment variables
config();

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

if (!supabaseUrl || !supabaseKey) {
  console.error('Missing Supabase credentials');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey);

interface ColumnInfo {
  column_name: string;
  data_type: string;
  is_nullable: string;
}

async function getTableSchema(schema: string, table: string): Promise<ColumnInfo[]> {
  const { data, error } = await supabase
    .from('information_schema.columns')
    .select('column_name, data_type, is_nullable')
    .eq('table_schema', schema)
    .eq('table_name', table);

  if (error) {
    console.error(`Error fetching schema for ${schema}.${table}:`, error);
    return [];
  }

  return data || [];
}

function postgresTypeToTypeScript(pgType: string): string {
  const typeMap: Record<string, string> = {
    'bigint': 'number',
    'bigserial': 'number',
    'bit': 'string',
    'bit varying': 'string',
    'boolean': 'boolean',
    'box': 'any',
    'bytea': 'string',
    'character': 'string',
    'character varying': 'string',
    'cidr': 'string',
    'circle': 'any',
    'date': 'string',
    'double precision': 'number',
    'inet': 'string',
    'integer': 'number',
    'interval': 'string',
    'json': 'any',
    'jsonb': 'any',
    'line': 'any',
    'lseg': 'any',
    'macaddr': 'string',
    'money': 'number',
    'numeric': 'number',
    'path': 'any',
    'pg_lsn': 'string',
    'point': 'any',
    'polygon': 'any',
    'real': 'number',
    'smallint': 'number',
    'smallserial': 'number',
    'serial': 'number',
    'text': 'string',
    'time': 'string',
    'time with time zone': 'string',
    'time without time zone': 'string',
    'timestamp': 'string',
    'timestamp with time zone': 'string',
    'timestamp without time zone': 'string',
    'tsquery': 'string',
    'tsvector': 'string',
    'txid_snapshot': 'string',
    'uuid': 'string',
    'xml': 'string'
  };

  return typeMap[pgType] || 'any';
}

function pascalCase(str: string): string {
  return str
    .split(/[_\s-]/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

async function generateTypesForConfig(configName: string, config: any) {
  const types: string[] = [
    '// Auto-generated types from dimension tables',
    '// Do not edit manually - generated by scripts/generate-filter-types.ts',
    '',
    `// Generated on: ${new Date().toISOString()}`,
    '',
  ];

  // Generate namespace
  types.push(`export namespace ${pascalCase(configName)}Filters {`);

  // Process each hierarchy level
  for (const level of config.hierarchy) {
    const [schema, table] = level.table.split('.');
    const columns = await getTableSchema(schema, table);

    if (columns.length === 0) {
      console.warn(`No columns found for ${level.table}`);
      continue;
    }

    // Generate interface
    types.push(`  export interface ${pascalCase(level.name)} {`);
    
    columns.forEach(col => {
      const tsType = postgresTypeToTypeScript(col.data_type);
      const nullable = col.is_nullable === 'YES' ? ' | null' : '';
      types.push(`    ${col.column_name}: ${tsType}${nullable};`);
    });
    
    types.push('  }');
    types.push('');

    // Generate specific type for value column
    types.push(`  export type ${pascalCase(level.name)}Value = ${pascalCase(level.name)}['${level.valueColumn}'];`);
    types.push(`  export type ${pascalCase(level.name)}Display = ${pascalCase(level.name)}['${level.displayColumn}'];`);
    types.push('');
  }

  // Generate composite types
  types.push('  export interface FilterState {');
  config.hierarchy.forEach((level: any) => {
    types.push(`    ${level.name}?: ${pascalCase(level.name)};`);
  });
  types.push('  }');
  types.push('');

  types.push('  export interface FilterValues {');
  config.hierarchy.forEach((level: any) => {
    types.push(`    ${level.name}?: ${pascalCase(level.name)}Value;`);
  });
  types.push('  }');
  types.push('');

  types.push('  export interface FilterSelection {');
  types.push('    level: string;');
  types.push('    value: any;');
  types.push('  }');

  types.push('}');
  types.push('');

  return types.join('\n');
}

async function generateAllTypes() {
  console.log('Generating TypeScript types for hierarchical filters...');

  const outputDir = path.join(process.cwd(), 'apps/web/src/types/generated');
  
  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Generate index file
  const indexTypes: string[] = [
    '// Auto-generated index for filter types',
    '// Do not edit manually',
    '',
  ];

  // Process each filter configuration
  for (const [configName, config] of Object.entries(scoutFilterConfigs)) {
    try {
      console.log(`Processing ${configName}...`);
      const types = await generateTypesForConfig(configName, config);
      
      // Write individual type file
      const filename = `${configName}-filters.ts`;
      const filepath = path.join(outputDir, filename);
      fs.writeFileSync(filepath, types, 'utf-8');
      
      console.log(`✓ Generated ${filename}`);
      
      // Add to index
      indexTypes.push(`export * from './${configName}-filters';`);
    } catch (error) {
      console.error(`Error generating types for ${configName}:`, error);
    }
  }

  // Write index file
  const indexPath = path.join(outputDir, 'index.ts');
  fs.writeFileSync(indexPath, indexTypes.join('\n'), 'utf-8');
  
  console.log('✓ Type generation complete!');
}

// Run the generator
generateAllTypes()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error('Fatal error:', error);
    process.exit(1);
  });